// Copyright (c) 2016, Laird
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
// SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
// IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
// SPDX-License-Identifier:ISC
//
// This is a sample app for demonstration purpose only
//
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// +++++                                                                      ++
// +++++  When UwTerminal downloads the app it will store it as a filenname   ++
// +++++  which consists of all characters up to the first . and excluding it ++
// +++++                                                                      ++
// +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//	
// $autorun$.devkit.sample.app.sb
// (Version 0.9)
//  -- Created to demonstrating the following:
//     - Range Test Service (Packet ID and RSSI)
//     - Voltage Service
//     - Temperature Service
//     - GPIO Service
//     - Virtual Serial Port Service
//
//******************************************************************************


//******************************************************************************
// Definitions
//******************************************************************************

//Error code result when the Ble advert is full
#define BleAdvertSpaceError                           0x6008

//Error code result when the Ble Buffer is full
#define BleBufferSpaceError                           0x6208

//Set to 1 to enable debug output printing
#define ENABLE_DEBUG_PRINTS                           1

//Size of VSP buffers (0 uses default)
#define TSZ                                           0  //TX
#define RSZ                                           0  //RX

//LSR 128 bit Base UUID (Using LSR UUID to be compatible with phone app)
#define LSR_BASE_UUID                                 "\33\47\00\00\FB\94\11\E2\A8\E4\F2\3C\91\AE\C0\5E"

//GPIO Service responsible for button notifications and turning LEDs on and off
#define GPIO_SVC_UUID                                 0xAAA0
#define INPUTS_CHAR_UUID                              0xAAA1
#define OUTPUTS_CHAR_UUID                             0xAAA2
#define BTNS_CHAR_UUID                                0xAAA3
#define LEDS_CHAR_UUID                                0xAAA4

//Range test service, reports RSSI and Packet ID
#define RANGE_SVC_UUID                                0xAAB0
#define RSSI_UUID                                     0xAAB1
#define PKT_ID_UUID                                   0xAAB2

//Temperature service, reports temperature data
#define TEMP_SVC_UUID                                 0xAAC0
#define TEMP_DATA_UUID                                0xAAC1

//Voltage service, reports the micro's Vcc
#define VCC_SVC_UUID                                  0xAAF0
#define VCC_DATA_UUID                                 0xAAF1

//Will advertise this name, appended with Bluetooth Address
#define DEVICENAME                                    "BL652"

//Version of this app in Device Info Service
#define SWREV                                         "1.0"

//GPIO Defines
#define GPIO_BTN0                                     11
#define GPIO_BTN1                                     15
#define GPIO_LED0                                     17
#define GPIO_LED1                                     19

//BLE EVENT MSG IDs
#define BLE_EVBLEMSGID_CONNECT                        0  //msgCtx = connection handle
#define BLE_EVBLEMSGID_DISCONNECT                     1  //msgCtx = connection handle

//Connection Defines
#define DEVICENAME_WRITABLE                           1
//BLE_APPEARANCE_GENERIC_TAG
#define APPEARANCE                                    512 

#define GPIO_TEMP_SENSOR                              3
//DiscoverableMode (2==General)
#define DISCOVERY_MODE                                2
//Advertise type (0==Connectable, 2==Not Connectable)
#define ADVERT_TYPE                                   0
//Advertising interval -- higher the number, lower the current consumption
//Recommended range 50 to 10000 
#define ADV_INTERVAL_MS                               250
//Advertise timeout (0==forever)
#define ADV_TIMEOUT_MS                                0
//Minimum acceptable connection interval (100 ms)
#define MIN_CONN_INTERVAL                             100000
//Maximum acceptable connection interval (150 ms).
#define MAX_CONN_INTERVAL                             150000
//Slave latency -- number of conn events that can be missed
//Effective Conn interval will be (SLAVE_LATENCY+1)*ACTUAL_CONN_INTERVAL
#define SLAVE_LATENCY                                 0
//Connection supervisory timeout (4 seconds) - max 32 seconds
#define CONN_SUP_TIMEOUT                              4000000

//******************************************************************************
// Register Error Handler as early as possible
//******************************************************************************
sub HandlerOnErr()
    if (ENABLE_DEBUG_PRINTS!=0) then
        print "\n OnErr - ";GetLastError();"\n"
    endif
endsub
onerror next HandlerOnErr

//******************************************************************************
// Global Variable Declarations
//******************************************************************************
dim stRsp$        //Uart rx data is stored here
dim rc            //Resultcode
dim dn$           //Device name
dim hGpioSvc      //GPIO Service handle
dim hRangeSvc     //Range Test Service handle
dim hTempSvc      //Temperature Service handle
dim hVccSvc       //Voltage Service handle
dim hSerLeds      //GATT Server LEDs characteristic handle
dim hSerBtns      //GPIO inputs (button) characteristic handle
dim hGpioSvcUuid  //GPIO service UUID handle
dim hRangeSvcUuid //Range Test Service UUID handle
dim hTempSvcUuid  //Temperature Service UUID handle 
dim hVccSvcUuid   //Voltage Service UUID handle
dim hRssi         //RSSI characteristic handle
dim hPktId        //Packet ID characteristic handle
dim PacketId      //Set to 1 once CCCD for char is enabled
dim hTempData     //Temperature Data characteristic handle
dim hVccData
dim uuhdl         //Service uuid handle for VSP
dim tx$           //VSP write data stored here
dim rx$           //VSP read data stored here
dim bufAvail      //Flag indicating OTA tx buf is available
dim BtnIndStat    //Status of Button indication descriptor
dim RangeIndStat  //Status of range indication descriptor
dim PktIDIndStat  //Status of packet ID indication descriptor
dim TempIndStat   //Status of temperature indication descriptor
dim VccIndStat    //Status of battery indication descriptor

//******************************************************************************
// Initialise Global Variable
//******************************************************************************
dn$          = DEVICENAME
bufAvail     = 1  //Assume available
PacketId     = 0
BtnIndStat   = 0
RangeIndStat = 0
PktIDIndStat = 0
TempIndStat  = 0
VccIndStat   = 0

//******************************************************************************
// Function and Subroutine definitions
//******************************************************************************

//------------------------------------------------------------------------------
// For debugging
//------------------------------------------------------------------------------
Sub AssertRC(rc,ln)
    if rc!=0 then
        if (ENABLE_DEBUG_PRINTS!=0) then
            print "\nFail :";integer.h' rc;" at tag ";ln
        endif
    endif
EndSub

//------------------------------------------------------------------------------
// Check if Ble buffer is full
//------------------------------------------------------------------------------
Sub CheckBleSend(rc)
    if (rc == BleBufferSpaceError) then
        //No space in buffer
        bufAvail = 0
    endif
EndSub

//------------------------------------------------------------------------------
// Initialise service and characteristics
//------------------------------------------------------------------------------
Sub CreateSvc()
    //Base UUID handle
    dim bseUuid$ : bseUuid$=LSR_BASE_UUID
    dim hBseUuid : hBseUuid=BleHandleUuid128(bseUuid$)

    hGpioSvcUuid=BleHandleUuidSibling(hBseUuid,GPIO_SVC_UUID)
    hRangeSvcUuid=BleHandleUuidSibling(hBseUuid,RANGE_SVC_UUID)
    hTempSvcUuid=BleHandleUuidSibling(hBseUuid,TEMP_SVC_UUID)
    hVccSvcUuid=BleHandleUuidSibling(hBseUuid,VCC_SVC_UUID)
    dim dta$ : dta$="\00"
    dim rc2,rc3
    dim hInputs
    dim hOutputs

    //***************************************************************************
    //Create Btn LED Service
    //***************************************************************************
    rc=BleServiceNew(1,hGpioSvcUuid,hGpioSvc)
    AssertRC(rc,211)

    //Initialise GATT Server Total Inputs Char - Read
    rc=BleCharNew(0x02, BleHandleUuidSibling(hBseUuid,(INPUTS_CHAR_UUID)), BleAttrMetaData(1,0,1,1,rc2),0,0)
    AssertRC(rc,215) : AssertRC(rc2,215) : AssertRC(rc3,215)
    rc=BleCharCommit(hGpioSvc,dta$,hInputs)
    AssertRC(rc,217)

    //Initialise GATT Server Total Outputs Char - Read
    rc=BleCharNew(0x02, BleHandleUuidSibling(hBseUuid,(OUTPUTS_CHAR_UUID)), BleAttrMetaData(1,0,1,1,rc2),0,0)
    AssertRC(rc,221) : AssertRC(rc2,221) : AssertRC(rc3,221)
    rc=BleCharCommit(hGpioSvc,dta$,hOutputs)
    AssertRC(rc,223)  

    //Initialise GATT Server LEDs Characteristic - Read/Write
    rc=BleCharNew(0x0A, BleHandleUuidSibling(hBseUuid,(LEDS_CHAR_UUID)), BleAttrMetaData(1,1,1,1,rc2),0,0)
    AssertRC(rc,227) : AssertRC(rc2,227) : AssertRC(rc3,227)
    rc=BleCharCommit(hGpioSvc,dta$,hSerLeds)
    AssertRC(rc,229)

    //Initialise GATT Server Buttons Characteristic - Read/Notify
    rc=BleCharNew(0x12, BleHandleUuidSibling(hBseUuid,(BTNS_CHAR_UUID)), BleAttrMetaData(1,0,2,1,rc2),0,0)
    AssertRC(rc,233) : AssertRC(rc2,233) : AssertRC(rc3,233)
    rc=BleCharCommit(hGpioSvc,dta$,hSerBtns)
    AssertRC(rc,235)

    rc=BleServiceCommit(hGpioSvc)
    AssertRC(rc,238)  

    //***************************************************************************
    //Create Range Test Service
    //***************************************************************************
    rc=BleServiceNew(1,hRangeSvcUuid,hRangeSvc)
    AssertRC(rc,244)

    //Initialise GATT Server RSSI Characteristic - Read/Notify
    rc=BleCharNew(0x12, BleHandleUuidSibling(hBseUuid,(RSSI_UUID)), BleAttrMetaData(1,0,2,1,rc2),0,0)
    AssertRC(rc,248) : AssertRC(rc2,248) : AssertRC(rc3,248)
    rc=BleCharCommit(hRangeSvc,dta$,hRssi)
    AssertRC(rc,250)

    //Initialise GATT Server Packet ID Characteristic - Read/Notify
    rc=BleCharNew(0x12, BleHandleUuidSibling(hBseUuid,(PKT_ID_UUID)), BleAttrMetaData(1,0,2,1,rc2),0,0)
    AssertRC(rc,254) : AssertRC(rc2,254) : AssertRC(rc3,254)
    rc=BleCharCommit(hRangeSvc,dta$,hPktId)
    AssertRC(rc,256)

    rc=BleServiceCommit(hRangeSvc)
    AssertRC(rc,259)

    //***************************************************************************
    //Create Temperature Service
    //***************************************************************************
    rc=BleServiceNew(1,hTempSvcUuid,hTempSvc)
    AssertRC(rc,265)

    //Initialise GATT Server Temperature Data Characteristic - Read/Notify
    rc=BleCharNew(0x12, BleHandleUuidSibling(hBseUuid,(TEMP_DATA_UUID)), BleAttrMetaData(1,0,2,1,rc2),0,0)
    AssertRC(rc,269) : AssertRC(rc2,269) : AssertRC(rc3,269)
    rc=BleCharCommit(hTempSvc,dta$,hTempData)
    AssertRC(rc,271)

    rc=BleServiceCommit(hTempSvc)
    AssertRC(rc,274)

    //***************************************************************************
    //Create Voltage Service
    //***************************************************************************
    rc=BleServiceNew(1,hVccSvcUuid,hVccSvc)
    AssertRC(rc,280)

    //Initialise GATT Server Temperature Data Characteristic - Read/Notify
    rc=BleCharNew(0x12, BleHandleUuidSibling(hBseUuid,(VCC_DATA_UUID)), BleAttrMetaData(1,0,2,1,rc2),0,0)
    AssertRC(rc,284) : AssertRC(rc2,284) : AssertRC(rc3,284)
    rc=BleCharCommit(hVccSvc,dta$,hVccData)
    AssertRC(rc,286)

    rc=BleServiceCommit(hVccSvc)
    AssertRC(rc,289)

    dim inputs$ : inputs$="\02"
    dim outputs$ : outputs$="\02"
    rc=BleCharValueWrite(hInputs,inputs$)
    AssertRC(rc,294)

    rc=BleCharValueWrite(hOutputs,outputs$)
    AssertRC(rc,297)

    dim initialVcc$ : initialVcc$ = "\30\00"
    rc=BleCharValueWrite(hVccData,initialVcc$)
    AssertRC(rc,301)

    dim intialZeroVal$ : intialZeroVal$ = "\00\00"
    rc=BleCharValueWrite(hSerBtns,intialZeroVal$)
    AssertRC(rc,305)
    rc=BleCharValueWrite(hPktId,intialZeroVal$)
    AssertRC(rc,307)
    rc=BleCharValueWrite(hTempData,intialZeroVal$)
    AssertRC(rc,309)
EndSub

//------------------------------------------------------------------------------
// Initialise advert reports
//------------------------------------------------------------------------------
Sub MakeAdvRpts()
    dim advRpt$, scnRpt$

    //Initialise the advert report
    rc = BleAdvRptInit(advRpt$, 2, 0, 0)
    AssertRC(rc,322)

    //Initialise scan report
    rc=BleScanRptInit(scnRpt$)
    AssertRC(rc,326)

    //Add 128-bit UUID to advert report
    rc = BLEADVRPTADDUUID128(advRpt$, uuhdl)
    AssertRC(rc,324)
    if (rc == BleAdvertSpaceError) then
        //No advert space
        print "There is insufficient space in the advert report to add a 128-bit UUID. This means that BLE devices will not detect the 128-bit service by scanning but the application is fully operational.\r\n"
        print "If VSP is enabled then disabling it will free up additional advert report space (remove the jumper from J5)."
    endif

    //Add 16-bit UUIDs to scan report
    rc = BleAdvRptAddUuid16(scnRpt$, GPIO_SVC_UUID, RANGE_SVC_UUID, TEMP_SVC_UUID, VCC_SVC_UUID, -1, -1)
    AssertRC(rc,323)

    //Add local name to scan report; append BT ADDR
    dim BTAddr$ : BTAddr$ = sysinfo$(4)
    BTAddr$ = strhexize$(BTAddr$)
    STRSHIFTLEFT(BTAddr$, 2)
    dn$ = dn$ + "-" + BTAddr$
    rc = BleAdvRptAppendAD(scnRpt$,0x09,dn$)
    AssertRC(rc,333)

    //Commit the advert and scan reports to the stack
    rc = BleAdvRptsCommit(advRpt$, scnRpt$)
    AssertRC(rc,337)
EndSub

//------------------------------------------------------------------------------
// Start connectable advertising
//------------------------------------------------------------------------------
Sub StartAdvertising()
    dim prAddr$ : prAddr$ = ""  //Peer BT address (not required for this app) hence empty
    rc = BleAdvertStart(ADVERT_TYPE, prAddr$, ADV_INTERVAL_MS, ADV_TIMEOUT_MS,0)
    AssertRC(rc,346)
EndSub

//------------------------------------------------------------------------------
// Initialise GPIOS
//------------------------------------------------------------------------------
Sub InitGpios()
    rc=gpiosetfunc(GPIO_BTN0,1,2)  //Button 0 digital input with weak pull up resistor
    AssertRC(rc,355)
    rc=gpiosetfunc(GPIO_BTN1,1,2)  //Button 1 digital input with weak pull up resistor
    AssertRC(rc,357)
    rc=GpioSetFunc(GPIO_LED0,2,0)  //Sets LED0 as a digital out
    AssertRC(rc,359)
    GpioWrite(GPIO_LED0,0)
    rc=GpioSetFunc(GPIO_LED1,2,0)  //Sets LED1 as a digital out
    AssertRC(rc,362)
    GpioWrite(GPIO_LED1,0)
EndSub

//------------------------------------------------------------------------------
// Enable ADC input for temp sensor
//------------------------------------------------------------------------------
sub EnableTempSensor()
    rc = GPIOSETFUNCEX(GPIO_TEMP_SENSOR, 3, "\00\0C\0A") //First byte selects the gain (default, 1/6 scaling), second byte selects the resolution (8, 10 or 12 bit) and the third byte selects the acquisition time (10us). See the BL652 extension manual for further details
    AssertRC(rc,374)
endsub

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
Sub OnStartup()
    //Open UART if it is not already open
    if (UartInfo(0) == 0) then
        rc = UartOpen(115200, 0, 0, "CN81H")
        AssertRC(rc,385)
    endif

    //Initialise the Gap Service
    rc=BleGapSvcInit(dn$, DEVICENAME_WRITABLE, APPEARANCE, MIN_CONN_INTERVAL, MAX_CONN_INTERVAL, CONN_SUP_TIMEOUT, SLAVE_LATENCY)
    AssertRC(rc,385)

    //Create the services
    CreateSvc()

    //Configure the GPIOs
    InitGpios()

    //Enable the temperature sensor
    EnableTempSensor()

    //Start a VSP server
    rc = BleVSpOpen(TSZ, RSZ, 0, uuhdl)
    AssertRC(rc,394)

    //Create the advert/scan reports
    MakeAdvRpts()

    //Start advertising
    StartAdvertising()

    //Enable events for when buttons are pressed
    rc=GpioBindEvent(0, GPIO_BTN0, 2)  //Binds a gpio transition high or low on button 0 to event 0
    AssertRC(rc,480)
    rc=GpioBindEvent(1, GPIO_BTN1, 2)  //Binds a gpio transition high or low on button 1 to event 1
    AssertRC(rc,482)

    //Output a message to the UART indicating that the application is running
    print "Welcome to the BL652 sample application!\r\nThis application can be tested with the X app available for:\r\n\t- Android: X\r\n\t- iOS: X\r\n\r\n"
    print "You can return to command mode (whereby the autorun application will not run at startup or on reset) by either:\r\n"
    print "\t- Unchecking DTR from UwTerminalX and pressing the reset button on the module or checking and unchecking the BREAK checkbox\r\n"
    print "\t- Move the J12 Autorun jumper to the L position (pins 2-3) and pressing the reset button on the module\r\n\r\n"
    print "You can reload this application any time from the BL652 Github repository: https://github.com/LairdCP/BL652-Applications by loading $autorun$.devkit.sample.app.sb\r\n"
EndSub

//******************************************************************************
// Handler definitions
//******************************************************************************

//------------------------------------------------------------------------------
// New Characteristic value
//------------------------------------------------------------------------------
Function HndlrCharVal(charHndl, offset, len)
    dim i,s$

    //Get characteristic value
    rc=BleCharValueRead(charHndl, s$)
    AssertRC(rc,411)

    if charHndl==hSerLeds then
        //Write values to LEDs
        dim onOrOffVal
        rc=BleDecodeU8(s$, onOrOffVal, 0)
        if ((onOrOffVal & 1) == 1) then
            GpioWrite(GPIO_LED0, 1)
        else
            GpioWrite(GPIO_LED0, 0)
        endif
        if ((onOrOffVal & 2) == 2) then
            GpioWrite(GPIO_LED1, 1)
        else
            GpioWrite(GPIO_LED1, 0)
        endif
    endif
EndFunc 1

//------------------------------------------------------------------------------
// Button transition handler
//------------------------------------------------------------------------------
Function HndlrGpio()
    dim val$

    rc=StrSetChr(val$, !GpioRead(GPIO_BTN1), 1)
    AssertRC(rc,460)
    rc=StrSetChr(val$, !GpioRead(GPIO_BTN0), 0)
    AssertRC(rc,462)

    if (BtnIndStat == 0) then
        //Update characteristic
        rc=BleCharValueWrite(hSerBtns, val$)
        AssertRC(rc,464)
    else
        //Notify
        if bufAvail==1 then
            rc=BleCharValueNotify(hSerBtns, val$)
            CheckBleSend(rc)
        endif
    endif
EndFunc 1

//------------------------------------------------------------------------------
// Ble event handler
//------------------------------------------------------------------------------
Function HndlrBleMsg(ByVal nMsgId, ByVal connHndl)
    select(nMsgId)
        case BLE_EVBLEMSGID_CONNECT
            //Enable RSSI signal strength monitoring
            rc=BleConnRssiStart(connHndl,4,10)
            AssertRC(rc,444)

            //Restart packet ID value
            PacketId = 0

            //Start timers for checking status of temperature sensor and battery level
            TimerStart(1, 1000, 1)
            TimerStart(2, 1000, 1)

            //Get current status of buttons
            rc=HndlrGpio()
        case BLE_EVBLEMSGID_DISCONNECT
            //Device disconnected. Disable all indications
            BtnIndStat = 0
            RangeIndStat = 0
            PktIDIndStat = 0
            TempIndStat = 0
            VccIndStat = 0

            //Cancel timers for updating characteristics
            TimerCancel(0)
            TimerCancel(1)
            TimerCancel(2)
            StartAdvertising()
        case else
    endselect
EndFunc 1

//------------------------------------------------------------------------------
// CCCD written
//------------------------------------------------------------------------------
Function HndlrCccd(charHndl, val)
    if charHndl == hPktId then
        PktIDIndStat = val
        if val==1 then
            PacketId=0
            TimerStart(0, 500, 1)
        else
            TimerCancel(0)
        endif
    elseif charHndl == hSerBtns then
        BtnIndStat = val
    elseif charHndl == hRssi then
        RangeIndStat = val
    elseif charHndl == hTempData then
        TempIndStat = val
    elseif charHndl == hVccData then
        VccIndStat = val
  endif
EndFunc 1

//-----------------------------------------------------------------------------
// Converts the adc reading to mV
//-----------------------------------------------------------------------------
function Adc2Mv(adc)
    //12-bit resolution
    adc = (adc*225)/256
endfunc adc

//-----------------------------------------------------------------------------
// Returns temperature in celsius times by 10 (260 = 26.0c)
//-----------------------------------------------------------------------------
function Mv2Temperature(mv)
    mv = ((mv*100 - 185830) / -117)
endfunc mv

//------------------------------------------------------------------------------
// Connection RSSI updated
//------------------------------------------------------------------------------
Function HndlrConnRssi(BYVAL charHandle, BYVAL rssi) AS INTEGER
    dim s$
    rc=BleEncode16(s$, rssi, 0)
    AssertRC(rc,546)

    if (RangeIndStat == 0) then
        rc=BleCharValuewrite(hRssi, s$)
    else
        if bufAvail==1 then
            rc=BleCharValueNotify(hRssi, s$)
            CheckBleSend(rc)
        endif
    endif
Endfunc 1

//------------------------------------------------------------------------------
// Timer 0 Expired
//------------------------------------------------------------------------------
Function HndlrTimer0()
    PacketId=PacketId+1
    dim s$
    rc=BleEncode16(s$, PacketId, 0)
    AssertRC(rc,562)
    rc=BleCharValueNotify(hPktId, s$)
    AssertRC(rc,568)
Endfunc 1 //Remain blocked in WAITEVENT

//------------------------------------------------------------------------------
// Timer 1 Expired
//------------------------------------------------------------------------------
Function HndlrTimer1()
    dim mv: mv= Adc2Mv(GpioRead(GPIO_TEMP_SENSOR))
    dim tmp: tmp= Mv2Temperature(mv)
    dim s$
    rc=BleEncode16(s$, tmp, 0)
    AssertRC(rc,575)

    if (TempIndStat == 0) then
        //Save to characteristic
        rc=BleCharValuewrite (hTempData, s$)
    else
        //Notify
        if bufAvail==1 then
            rc=BleCharValueNotify(hTempData, s$)
            CheckBleSend(rc)
        endif
    endif
Endfunc 1 //Remain blocked in WAITEVENT

//------------------------------------------------------------------------------
// Timer 2 Expired
//------------------------------------------------------------------------------
Function HndlrTimer2()
    dim mv: mv=READPWRSUPPLYMV()
    dim s$
    rc=BleEncode16(s$, mv, 0)
    AssertRC(rc,591)

    if (VccIndStat == 0) then
        //Save to characteristic
        rc=BleCharValuewrite(hVccData, s$)
    else
        //Notify
        if (bufAvail == 1) then
            rc=BleCharValueNotify(hVccData, s$)
            CheckBleSend(rc)
        endif
    endif
Endfunc 1 //Remain blocked in WAITEVENT

//==============================================================================
// This handler is called when data has arrived at the serial port
//==============================================================================
function HandlerUartRx() as integer
    if (bufAvail == 1) then
        //Buffer space is available
        dim n

        //Read up to 20 bytes from the UART if string is empty
        if (strlen(tx$) == 0) then
            n = UartReadN(tx$, 20)
        endif

        //Check if there is any data to send
        if (n > 0 || strlen(tx$) > 0) then
            //Write the data out over VSP and remove characters from the buffer that were sent
            n = BleVSpWrite(tx$)
            strshiftleft(tx$, n)

            if (n != strlen(tx$)) then
                //Not all bytes were sent, pause sending until next TxBufAvail event
                bufavail = 0
            endif
        endif
    endif
endfunc 1

//==============================================================================
// This handler is called when data has arrived at the virtual serial port
//==============================================================================
function HndlrVspDataRxd() as integer
    dim rxn

    //Reaching here means there could be at least 1 byte space in tx buffer
    rxn = BleVSpRead(rx$, 20)
    if rxn == 0 then
        //The rx buffer was empty
        exitfunc 1
    endif

    //If we get here data is available to print
    print rx$
endfunc 1

//==============================================================================
// This handler is called when OTA Tx buffer is available
//==============================================================================
function HndlrTxBufAvail() as integer
    //Buffer now has free space
    bufAvail=1

    //Check if there is any additional UART data to send
    rc = HandlerUartRx()
endfunc 1

//******************************************************************************
// Equivalent to main() in C
//******************************************************************************
OnStartup()

OnEvent EVUARTRX     call HandlerUartRx
OnEvent EvCharVal    call HndlrCharVal
OnEvent EvBleMsg     call HndlrBleMsg
OnEvent EvCharCccd   call HndlrCccd
OnEvent EvGpioChan0  call HndlrGpio
OnEvent EvGpioChan1  call HndlrGpio
OnEvent EvConnRssi   call HndlrConnRssi
OnEvent EvTmr0       call HndlrTimer0
OnEvent EvTmr1       call HndlrTimer1
OnEvent EvTmr2       call HndlrTimer2
OnEvent EVVSPRX      call HndlrVspDataRxd
OnEvent EVVSPTXEMPTY call HndlrVspDataRxd
OnEvent EVNOTIFYBUF  call HndlrTxBufAvail

//------------------------------------------------------------------------------
// Wait for a synchronous event.
// An application can have multiple <WaitEvent> statements
//------------------------------------------------------------------------------
WaitEvent
